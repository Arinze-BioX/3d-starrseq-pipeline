import json

shell.prefix("set -eo pipefail; echo BEGIN at $(date); ")
shell.suffix("; exitstat=$?; echo END at $(date); echo exit status was $exitstat; exit $exitstat")

configfile: "config.yaml"

smooth_window  = 150
shiftsize      = -75
genome_version = 'hs'
pval_thresh    = 0.05

FILES      = json.load(open(config['SAMPLES_JSON']))
SAMPLES    = sorted(FILES.keys())
BWA_INDEX  = config['BWA_INDEX']
chromsizes = config['chromsizes']
genome     = config['genome']
frag_path  = config['frag_path']
cool_bin   = config['cool_bin']
nla3_bed   = config['nla3_bed']


TARGETS = []
peaks  = expand("macs2_peak/{sample}_{genome}_peaks.narrowPeak" , sample = SAMPLES, genome = genome)
counts = expand("final_bed-{genome}/{sample}_unique_pairs_with_counts.bed", sample = SAMPLES, genome = genome)
cooler = expand("coolers-{genome}/{sample}.{cool_bin}.cool", sample = SAMPLES, genome = genome, cool_bin = cool_bin)
TARGETS.extend(peaks)
TARGETS.extend(counts)
TARGETS.extend(cooler)



localrules: all


rule all:
    input: TARGETS

rule fastq_select_valid:
    input:
        r1 = lambda wildcards: FILES[wildcards.sample]['R1'],
        r2 = lambda wildcards: FILES[wildcards.sample]['R2']
    output: 
        "00_valid_fastq/{sample}_valid_r1.fq.gz", 
        "00_valid_fastq/{sample}_valid_r2.fq.gz"
    threads: 12
    resources:
        mem="30G"
    message: "select reads with correct orientation"
    log:
         "00_log/{sample}.removeadapt"
    shell:
        """cutadapt -Z -j {threads} -e 0.16 --action none --discard-untrimmed -g ^ACANNNNTGTGCGAACTCAGACC -o {output[0]} -p {output[1]} {input[0]} {input[1]} 2> {log}
"""
    
  
rule fastq_UMI_extraction:
    input:
        "00_valid_fastq/{sample}_valid_r1.fq.gz", 
        "00_valid_fastq/{sample}_valid_r2.fq.gz"
    output: 
        "00_UMI_named_fq/{sample}_UMIextracted_r1.fq.gz", 
        "00_UMI_named_fq/{sample}_UMIextracted_r2.fq.gz"
    threads: 12
    message: "Remove non-biological sequences and add umi to read name for already demultiplexed reads"
    log:
         "00_log/{sample}.extractUMI", "00_log/{sample}.extractUMI_error"
    shell:
        """umi_tools extract --extract-method=regex --ignore-read-pair-suffixes --bc-pattern='(?P<discard_1>.{{23}})' \
--bc-pattern2='.+(?P<discard_1>.{{10}})(?P<umi_2>.{{8}})(?P<discard_2>.{{12}})' \
--log={log[0]} -I {input[0]} -S {output[0]} \
--read2-in={input[1]} --read2-out={output[1]} > {log[1]}
"""

rule bwa_mem_mapping:
    input:
        r1 = "00_UMI_named_fq/{sample}_UMIextracted_r1.fq.gz",
        r2 = "00_UMI_named_fq/{sample}_UMIextracted_r2.fq.gz"
    output: "01_bam/{sample}.bam"
    threads: 24
    resources:
        mem="30G"
    message: "bwa {input}: {threads} threads"
    log:
        "00_log/{sample}.bwa"
    shell:
        """bwa mem  -SP -t {threads} {BWA_INDEX} {input} | samtools view -bS - > {output}  2> {log}"""

rule samtools_sort_bam:
    input:  "01_bam/{sample}.bam"
    output: "02_bam/{sample}.bam"
    threads: 1
    message: "samtools index bam files for deduplication {input}: {threads} threads"
    log:
        "00_log/{sample}_sort.samtools", "00_log/{sample}_index.samtools"
    shell:
        """
        samtools sort {input} -o {output} 2> {log[0]}
        """

rule samtools_index:
    input:  "02_bam/{sample}.bam"
    output: "02_bam/{sample}.bam.bai"
    threads: 1
    message: "bam indexing"
    log:
        "00_log/{sample}_index.samtools"
    shell:
        """samtools index {input}"""


rule UMItools_deduplication:
    input:  "02_bam/{sample}.bam","02_bam/{sample}.bam.bai"
    output: "umicollapse_dedup/{sample}_UMIcollapse_dedup.bam"
    threads: 24
    resources:
        mem="50G"
    message: "umitools deduplication based on UMI {input}: {threads} threads"
    log:
        "00_log/{sample}_dedupLog.umitools", "00_log/{sample}_name_sort.samtools"
    shell:
        """
        source /datacommons/ydiaolab/arinze/apps/miniconda_20220118/etc/profile.d/conda.sh
        conda activate snakemake_3dstarrseq
        umi_tools dedup --stdin={input[0]} --log={log[0]} --unpaired-reads=discard --paired | samtools sort -n -o {output}  2> {log[1]}"""

rule index_collapsed:
    input:  "umicollapse_dedup/{sample}_UMIcollapse_dedup.bam"
    output: "umicollapse_dedup/{sample}_UMIcollapse_dedup.bam.bai"
    threads: 1
    message: "collapsed bam indexing"
    log:
        "00_log/{sample}_index_collapsed.samtools"
    shell:
        """samtools index {input}"""

rule parse_pairs_from_BAM_files: ## no flip to makesure the R1 R2 position for the peak calling. After standard columns, also outputs restriction fragment index (for pos1), res. frag. start for pos1, res. end for pos 1, then same columns for pos 2.
    input:  "umicollapse_dedup/{sample}_UMIcollapse_dedup.bam"
    output: "pairs-{genome}/{sample}.raw.pairsam.gz", "pairs-{genome}/{sample}.raw.pairsam.stat"
    message: "parse bam {input} "
    threads: 2
    shell:
        """
pairtools parse -c {chromsizes}  --assembly {genome} --min-mapq 10 --max-molecule-size 2000 --max-inter-align-gap 20 --walks-policy mask  --no-flip --drop-seq --drop-sam  --output-stats {output[1]} -o {output[0]}  {input} 
"""

rule select_valid_pairs:
    input:  "pairs-{genome}/{sample}.raw.pairsam.gz"
    output: "pairs-{genome}/{sample}.selected.pairs.gz"
    message: "flip and sort {input} "
    threads: 8
    shell:
        """pairtools flip -c {chromsizes} {input} | pairtools select '(pair_type=="UU") or (pair_type=="UR") or (pair_type=="RU")' | pairtools sort  --nproc 8  --memory 15G  -o {output}
"""

rule count_duplicate_pairs:
    input:  "pairs-{genome}/{sample}.selected.pairs.gz"
    output: "final_bed-{genome}/{sample}_unique_pairs_with_counts.bed"
    threads: 12
    resources:
        mem="100G"
    message: "count fragments per position"
    log:
        "00_log/{sample}_{genome}_count_finalBed.bedtools_groupby"
    shell:
        """
        source /datacommons/ydiaolab/arinze/apps/miniconda_20220118/etc/profile.d/conda.sh
        conda activate bedtools
        zcat {input} | awk -F '[t]' ' /^[^#]/ {{ print $0 }}' |\
        bedtools groupby -g 2-7 -c 5 -o count |\
        awk '{{ print $1"\\t"$2"\\t"$5"\\t"$7"\\t"$1"_"$2"_"$3"_"$4"\\n"$3"\\t"$4"\\t"$6"\\t"$7"\\t"$1"_"$2"_"$3"_"$4 }}' |\
        awk '{{ if ($3 == "+") {{ print $1"\\t"$2"\\t"($2+1)"\\t"$5"\\t"$4"\\t"$3}} else if ($3 == "-") {{ print $1"\\t"($2-1)"\\t"$2"\\t"$5"\\t"$4"\\t"$3}}}}' |\
        bedtools intersect -a stdin -b /datacommons/ydiaolab/arinze/ThreeD_STARRseq/new_genome_files/hg38_nla3.bed -wa -wb |\
        awk '{{ if ($6 == "+") {{ print $1"\\t"$2"\\t"$9"\\t"$4"\\t"$5"\\t"$6 }} else if ($6 == "-") {{ print $1"\\t"$8"\\t"$3"\\t"$4"\\t"$5"\\t"$6 }} }}' |\
        paste -sd '\\t\\n' | awk '{{ if($4 == $10) {{print $1"\\t"$2"\\t"$3"\\t"$7"\\t"$8"\\t"$9"\\t"$1"_"$2"_"$3"-"$7"_"$8"_"$9"\\t"$5"\\t"$6"\\t"$12}} }}' > {output} 2> {log}
        """


rule remove_duplicate_pairs:
    input:  "pairs-{genome}/{sample}.selected.pairs.gz"
    output: "filtered-{genome}/{sample}.dedup.pairs.gz" ,"filtered-{genome}/{sample}.dedup.pairs.stat"
    message: "dedup to filted {input} "
    threads: 5
    shell:
        """
pairtools dedup --max-mismatch 1 --method max -o {output[0]} {input} --output-stats  {output[1]}
"""

rule remove_same_fragment_pairs:
    input:  "filtered-{genome}/{sample}.dedup.pairs.gz"
    output: valid = "filtered-{genome}/{sample}.valid.pairs.gz", same_f = "filtered-{genome}/{sample}.samefrag.pairs.gz"
    message: "selected pairsam {input} "
    threads: 5
    shell:
        """
pairtools restrict -f {frag_path} {input} | pairtools select '(COLS[-6]==COLS[-3]) and (chrom1==chrom2)' --output-rest {output[valid]} -o {output[same_f]} 
"""

rule make_index:
    input:  "filtered-{genome}/{sample}.valid.pairs.gz"
    output: "filtered-{genome}/{sample}.valid.pairs.gz.px2"
    message: "dedup to filted {input} "
    threads: 5
    shell:
        """
pairix -p pairs  {input}
"""
        
rule extract_R2_ATAC_reads:
    input:  "pairs-{genome}/{sample}.raw.pairsam.gz"
    output: "peaks-{genome}/{sample}.longRange_Trans.pairs.gz", "peaks-{genome}/{sample}.short.pairs.gz"
    message: "flip to filted {input} "
    threads: 8
    shell:
        """
pairtools select '(pair_type=="UU") or (pair_type=="UR") or (pair_type=="RU")' {input} | pairtools select '(chrom1==chrom2) and (abs(pos1 - pos2) < 1e4)'  -o {output[1]}  --output-rest {output[0]} 
"""

rule ATAC_reads_Tn5_shifting_duplicate_remove:  
    input:  "peaks-{genome}/{sample}.longRange_Trans.pairs.gz"
    output: "peaks-{genome}/{sample}.R2.ATAC.bed.gz"
    threads: 1
    shell:
        """
zcat {input} | awk ' BEGIN {{OFS="\\t"}} ;  /^[^#]/ {{ {{ if ($7 == "+") {{$5 = $5 + 4}} else if ($7 == "-") {{$5 = $5 - 5}}  print $4, $5, $5+1, "*", "*", $7}} }} ' | sort -k1,1 -k2,2n | uniq  | gzip -nc > {output}
"""

rule ATAC_macs2_peaks:
    input:  "peaks-{genome}/{sample}.R2.ATAC.bed.gz"
    output: "macs2_peak/{sample}_{genome}_peaks.narrowPeak"
    threads:1
    params: name = "{sample}_{genome}"
    shell:
        """
macs2 callpeak -t {input} -f BED -n {params.name}  -g {genome_version} --qval {pval_thresh} --shift {shiftsize} --extsize {smooth_window} --nomodel -B --SPMR --keep-dup all --call-summits --outdir macs2_peak 
"""

rule HiC_contact_matrices_Cooler:
    input:  "filtered-{genome}/{sample}.valid.pairs.gz", "filtered-{genome}/{sample}.valid.pairs.gz.px2"
    output: "coolers-{genome}/{sample}.{cool_bin}.cool"
    message: "cooler {input} "
    params: res = {cool_bin}
    priority: 100
    threads: 10
    shell:
        """
cooler cload pairix --assembly hg38 --nproc {threads} --max-split 2 {chromsizes}:{params.res} {input[0]} {output}
"""

checkpoint check_all_cool:
    input: HiCrep = rules.HiC_contact_matrices_Cooler.output
    priority: 90
    message: "Checking that all cool files have been generated at least 1 minute ago"
    output: touch("checks/check_all_cool.done")
    # Ensure at least 1 minute has passed since the last modification of any output file
    shell:
        """
        sleep 60
        # Exit with non-zero code if any step1 output is missing
        if [ $(ls coolers-{genome}/*.cool | wc -l) -ne {len(SAMPLES)} ]; then
        exit 1
        fi
        for f in {input.HiCrep}; do
            if [[ $(stat -c %y "$f") < $(date +%s -v -1m +%s) ]]; then
            echo "Error: File $f might be incomplete (modified less than 1 minute ago)"
            exit 1
            fi
        done
        """

rule HiCrep:
    input: path="coolers-{genome}/", file="{sample}"
    output: touch("hicrep_check/coolers-{genome}-{sample}-{cool_bin}.done")
    params: path="hicrep/"
    threads:1
    log:
        "00_log/{sample}_{cool_bin}_{genome}.hicrep"
    shell:
        """
        source /datacommons/ydiaolab/arinze/apps/miniconda_20220118/etc/profile.d/conda.sh
        conda activate hicrep
        Rscript hicRep_parallel.R {input.path} {input.file} {params.path} 2> {log}
        """