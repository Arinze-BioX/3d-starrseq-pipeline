#!/datacommons/ydiaolab/arinze/apps/miniconda_20220118/envs/snakemake_3dstarrseq/bin/python

import json

smooth_window  = 150
shiftsize      = -75
genome_version = 'hs'
pval_thresh    = 0.05

FILES      = json.load(open(config['SAMPLES_JSON']))
SAMPLES    = sorted(FILES.keys())
BWA_INDEX  = config['BWA_INDEX']
chromsizes = config['chromsizes']
genome     = config['genome']
frag_path  = config['frag_path']
cool_bin   = config['cool_bin']
nla3_bed   = config['nla3_bed']


TARGETS = []
peaks  = expand("macs2_peak/{sample}_{genome}_peaks.narrowPeak" , sample = SAMPLES, genome = genome)
counts = expand("final_bed-{genome}/{sample}_unique_pairs_with_counts.bedpe", sample = SAMPLES, genome = genome)
cooler = expand("coolers-{genome}/{sample}.{cool_bin}.cool", sample = SAMPLES, genome = genome, cool_bin = cool_bin)
TARGETS.extend(peaks)
TARGETS.extend(counts)
TARGETS.extend(cooler)

localrules: all


rule all:
    input: TARGETS, "checks/check_all_cool.done"

rule fastq_select_valid:
    input:
        r1 = lambda wildcards: FILES[wildcards.sample]['R1'],
        r2 = lambda wildcards: FILES[wildcards.sample]['R2']
    output: 
        "00_valid_fastq/{sample}_valid_r1.fq.gz", 
        "00_valid_fastq/{sample}_valid_r2.fq.gz"
    threads: 12
    message: "select reads with correct orientation"
    log:
         "00_log/{sample}_stdOut.removeadapt","00_log/{sample}_error.removeadapt"
    shell:
        """cutadapt -Z -j {threads} -e 0.16 --action none --discard-untrimmed -g ^ACANNNNTGTGCGAACTCAGACC -o {output[0]} -p {output[1]} {input[0]} {input[1]} 1> {log[0]} 2> {log[1]}
"""
    
  
rule fastq_UMI_extraction:
    input:
        "00_valid_fastq/{sample}_valid_r1.fq.gz", 
        "00_valid_fastq/{sample}_valid_r2.fq.gz"
    output: 
        "00_UMI_named_fq/{sample}_UMIextracted_r1.fq.gz", 
        "00_UMI_named_fq/{sample}_UMIextracted_r2.fq.gz"
    threads: 12
    message: "Remove non-biological sequences and add umi to read name for already demultiplexed reads"
    log:
         "00_log/{sample}.extractUMI", "00_log/{sample}.extractUMI_error"
    shell:
        """umi_tools extract --extract-method=regex --ignore-read-pair-suffixes --bc-pattern='(?P<discard_1>.{{23}})' \
--bc-pattern2='.+(?P<discard_1>.{{10}})(?P<umi_2>.{{8}})(?P<discard_2>.{{12}})' \
--log={log[0]} -I {input[0]} -S {output[0]} \
--read2-in={input[1]} --read2-out={output[1]} 2> {log[1]}
"""

rule bwa_mem_mapping:
    input:
        r1 = "00_UMI_named_fq/{sample}_UMIextracted_r1.fq.gz",
        r2 = "00_UMI_named_fq/{sample}_UMIextracted_r2.fq.gz"
    output: "01_bam/{sample}.bam"
    threads: 24
    resources:
            mem="50G"
    message: "bwa {input}: {threads} threads"
    log:
        "00_log/{sample}_err.bwa"
    shell:
        """bwa mem  -SP -t {threads} {BWA_INDEX} {input} | samtools view -bS - > {output}  2> {log}"""

rule samtools_sort_bam:
    input:  "01_bam/{sample}.bam"
    output: "02_bam/{sample}.bam"
    threads: 1
    message: "samtools index bam files for deduplication {input}: {threads} threads"
    log:
        "00_log/{sample}_sort_err.samtools"
    shell:
        """
        samtools sort {input} -o {output} 2> {log}
        """

rule samtools_index:
    input:  "02_bam/{sample}.bam"
    output: "02_bam/{sample}.bam.bai"
    threads: 1
    message: "bam indexing"
    log:
        "00_log/{sample}_index.samtools"
    shell:
        """samtools index {input}"""


rule UMItools_deduplication:
    input:  "02_bam/{sample}.bam","02_bam/{sample}.bam.bai"
    output: "umicollapse_dedup/{sample}_UMIcollapse_dedup.bam"
    threads: 24
    resources:
        mem="50G"
    message: "umitools deduplication based on UMI {input}: {threads} threads"
    log:
        "00_log/{sample}_dedupLog.umitools", "00_log/{sample}_name_sort.samtools"
    shell:
        """
        umi_tools dedup --stdin={input[0]} --log={log[0]} --unpaired-reads=discard --paired | samtools sort -n -o {output}  2> {log[1]}"""


rule parse_pairs_from_BAM_files: ## no flip to makesure the R1 R2 position for the peak calling. After standard columns, also outputs restriction fragment index (for pos1), res. frag. start for pos1, res. end for pos 1, then same columns for pos 2.
    input:  "umicollapse_dedup/{sample}_UMIcollapse_dedup.bam"
    output: "pairs-{genome}/{sample}.raw.pairsam.gz", "pairs-{genome}/{sample}.raw.pairsam.stat"
    message: "parse bam {input} "
    threads: 2
    log:
        "00_log/{sample}_{genome}_parsePairs.pairtools"
    shell:
        """
pairtools parse -c {chromsizes}  --assembly {genome} --min-mapq 10 --max-molecule-size 2000 --max-inter-align-gap 20 --walks-policy mask  --no-flip --drop-seq --drop-sam  --output-stats {output[1]} -o {output[0]}  {input[0]} 2> {log}
"""

rule select_valid_pairs:
    input:  "pairs-{genome}/{sample}.raw.pairsam.gz"
    output: "pairs-{genome}/{sample}.selected.pairs.gz"
    message: "flip and sort {input} "
    threads: 8
    log:
        "00_log/{sample}_{genome}_selectValidPairs.pairtools"
    shell:
        """pairtools flip -c {chromsizes} {input[0]} | pairtools select '(pair_type=="UU") or (pair_type=="UR") or (pair_type=="RU")' | pairtools sort  --nproc 8  --memory 15G  -o {output} 2> {log}
"""

rule count_duplicate_pairs:
    input:  "pairs-{genome}/{sample}.selected.pairs.gz"
    output: "final_bed-{genome}/{sample}_unique_pairs_with_counts.bedpe"
    threads: 4
    resources:
        mem="120G"
    message: "count fragments per position"
    log:
        "00_log/{sample}_{genome}_count_finalBed.bedtools_groupby"
    shell:
        """
set +eu
source /datacommons/ydiaolab/arinze/apps/miniconda_20220118/etc/profile.d/conda.sh
conda activate bedtools
set -eu
zcat {input} | awk -F '[t]' ' /^[^#]/ {{ print $0 }}' |\
bedtools groupby -g 2-7 -c 5 -o count |\
awk '{{ print $1"\\t"$2"\\t"$5"\\t"$7"\\t"$1"_"$2"_"$3"_"$4"\\n"$3"\\t"$4"\\t"$6"\\t"$7"\\t"$1"_"$2"_"$3"_"$4 }}' |\
awk '{{ if ($3 == "+") {{ print $1"\\t"$2"\\t"($2+1)"\\t"$5"\\t"$4"\\t"$3}} else if ($3 == "-") {{ print $1"\\t"($2-1)"\\t"$2"\\t"$5"\\t"$4"\\t"$3}}}}' |\
bedtools intersect -a stdin -b /datacommons/ydiaolab/arinze/ThreeD_STARRseq/new_genome_files/hg38_nla3.bed -wa -wb |\
awk '{{ if ($6 == "+") {{ print $1"\\t"$2"\\t"$9"\\t"$4"\\t"$5"\\t"$6 }} else if ($6 == "-") {{ print $1"\\t"$8"\\t"$3"\\t"$4"\\t"$5"\\t"$6 }} }}' |\
paste -sd '\\t\\n' | awk '{{ if($4 == $10) {{print $1"\\t"$2"\\t"$3"\\t"$7"\\t"$8"\\t"$9"\\t"$1"_"$2"_"$3"-"$7"_"$8"_"$9"\\t"$5"\\t"$6"\\t"$12}} }}' > {output} 2> {log}
"""


rule remove_duplicate_pairs:
    input:  "pairs-{genome}/{sample}.selected.pairs.gz"
    output: "filtered-{genome}/{sample}.dedup.pairs.gz" ,"filtered-{genome}/{sample}.dedup.pairs.stat"
    message: "dedup to filted {input} "
    threads: 5
    log:
        "00_log/{sample}_{genome}_removeDuplicateFragments.pairtools"
    shell:
        """
pairtools dedup --max-mismatch 1 --method max -o {output[0]} {input} --output-stats  {output[1]} 2> {log}
"""

rule remove_same_fragment_pairs:
    input:  "filtered-{genome}/{sample}.dedup.pairs.gz"
    output: valid = "filtered-{genome}/{sample}.valid.pairs.gz", same_f = "filtered-{genome}/{sample}.samefrag.pairs.gz"
    message: "selected pairsam {input} "
    threads: 5
    log:
        "00_log/{sample}_{genome}_removeSameFragmentPairs.pairtools"
    shell:
        """
pairtools restrict -f {frag_path} {input} | pairtools select '(COLS[-6]==COLS[-3]) and (chrom1==chrom2)' --output-rest {output[valid]} -o {output[same_f]} 2> {log}
"""

rule make_index:
    input:  "filtered-{genome}/{sample}.valid.pairs.gz"
    output: "filtered-{genome}/{sample}.valid.pairs.gz.px2"
    message: "dedup to filted {input} "
    threads: 5
    shell:
        """
pairix -p pairs  {input}
"""
        
rule extract_R2_ATAC_reads:
    input:  "pairs-{genome}/{sample}.raw.pairsam.gz"
    output: "peaks-{genome}/{sample}.longRange_Trans.pairs.gz", "peaks-{genome}/{sample}.short.pairs.gz"
    message: "flip to filted {input} "
    threads: 8
    log:
        "00_log/{sample}_{genome}_removeDuplicateFragments.pairtools"
    shell:
        """
pairtools select '(pair_type=="UU") or (pair_type=="UR") or (pair_type=="RU")' {input} | pairtools select '(chrom1==chrom2) and (abs(pos1 - pos2) < 1e4)'  -o {output[1]}  --output-rest {output[0]} 2> {log}
"""

rule ATAC_reads_Tn5_shifting_duplicate_remove:  
    input:  "peaks-{genome}/{sample}.longRange_Trans.pairs.gz"
    output: "peaks-{genome}/{sample}.R2.ATAC.bed.gz"
    threads: 1
    shell:
        """
zcat {input} | awk ' BEGIN {{OFS="\\t"}} ;  /^[^#]/ {{ {{ if ($7 == "+") {{$5 = $5 + 4}} else if ($7 == "-") {{$5 = $5 - 5}}  print $4, $5, $5+1, "*", "*", $7}} }} ' | sort -k1,1 -k2,2n | uniq  | gzip -nc > {output}
"""

rule ATAC_macs2_peaks:
    input:  "peaks-{genome}/{sample}.R2.ATAC.bed.gz"
    output: "macs2_peak/{sample}_{genome}_peaks.narrowPeak"
    threads:1
    params: name = "{sample}_{genome}"
    shell:
        """
macs2 callpeak -t {input} -f BED -n {params.name}  -g {genome_version} --qval {pval_thresh} --shift {shiftsize} --extsize {smooth_window} --nomodel -B --SPMR --keep-dup all --call-summits --outdir macs2_peak 
"""

rule HiC_contact_matrices_Cooler:
    input:  "filtered-{genome}/{sample}.valid.pairs.gz", "filtered-{genome}/{sample}.valid.pairs.gz.px2"
    output: "coolers-{genome}/{sample}.{cool_bin}.cool"
    message: "cooler {input} "
    params: res = {cool_bin}
    threads: 10
    shell:
        """
cooler cload pairix --assembly hg38 --nproc {threads} --max-split 2 {chromsizes}:{params.res} {input[0]} {output}
"""

rule check_all_cool:
    input: expand("coolers-{genome}/{sample}.{cool_bin}.cool", sample = SAMPLES, genome=genome, cool_bin=cool_bin)
    message: "Checking that all cool files have been generated at least 1 minute ago"
    output: "checks/check_all_cool.done"
    # Ensure at least 1 minute has passed since the last modification of any output file
    shell:
        """
        sleep 60
        # Exit with non-zero code if any step1 output is missing
        if [ $(ls ./coolers-{genome}/*.cool | wc -l) -ne {len(SAMPLES)} ]; then
        exit 1
        fi
        touch {output}
        """

rule HiCrep:
    input: path="coolers-{genome}/", file="{sample}", check_file="checks/check_all_cool.done"
    output: touch("hicrep_check/coolers-{genome}-{sample}-{cool_bin}.done")
    params: path="hicrep/"
    threads:1
    log:
        "00_log/{sample}_{cool_bin}_{genome}.hicrep"
    shell:
        """
        set +eu
        source /datacommons/ydiaolab/arinze/apps/miniconda_20220118/etc/profile.d/conda.sh
        conda activate hicrep
        set -eu
        Rscript hicRep_parallel.R {input.path} {input.file} {params.path} 2> {log}
        """